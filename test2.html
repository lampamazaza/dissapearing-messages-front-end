<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    /*
    Derive an AES key, given:
    - our ECDH private key
    - their ECDH public key
    */
    function deriveSecretKey(privateKey, publicKey) {
      return window.crypto.subtle.deriveKey(
        {
          name: "ECDH",
          public: publicKey,
        },
        privateKey,
        {
          name: "AES-GCM",
          length: 256,
        },
        false,
        ["encrypt", "decrypt"]
      );
    }

    async function agreeSharedSecretKey() {
      // Generate 2 ECDH key pairs: one for Alice and one for Bob
      // In more normal usage, they would generate their key pairs
      // separately and exchange public keys securely
      let alicesKeyPair = await window.crypto.subtle.generateKey(
        {
          name: "ECDH",
          namedCurve: "P-384",
        },
        false,
        ["deriveKey"]
      );

      let bobsKeyPair = await window.crypto.subtle.generateKey(
        {
          name: "ECDH",
          namedCurve: "P-384",
        },
        false,
        ["deriveKey"]
      );

      let xKeyPair = await window.crypto.subtle.generateKey(
        {
          name: "ECDH",
          namedCurve: "P-384",
        },
        false,
        ["deriveKey"]
      );

      // Alice then generates a secret key using her private key and Bob's public key.
      let alicesSecretKey = await deriveSecretKey(
        alicesKeyPair.privateKey,
        bobsKeyPair.publicKey
      );

      // Bob generates the same secret key using his private key and Alice's public key.
      let bobsSecretKey = await deriveSecretKey(
        bobsKeyPair.privateKey,
        alicesKeyPair.publicKey
      );

      // Bob generates the same secret key using his private key and Alice's public key.
      let xSecretKey = await deriveSecretKey(
        xKeyPair.privateKey,
        alicesKeyPair.publicKey
      );

      const msg =
        "Lorem Ipsum - это текст-рыба, часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной рыбой для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum.";
      const iv = window.crypto.getRandomValues(new Uint8Array(12));
      const msgFromAliceToBob = await encryptMessage(alicesSecretKey, msg, iv);

      console.log(msgFromAliceToBob);

      const decryptedMsgFromAliceToBob = await decryptMessage(
        xSecretKey,
        msgFromAliceToBob,
        iv
      );

      console.log(decryptedMsgFromAliceToBob);
    }

    async function encryptMessage(key, message, iv) {
      const encodedMessage = new TextEncoder().encode(message);
      const encoded = await window.crypto.subtle.encrypt(
        {
          name: "AES-GCM",
          iv: iv,
        },
        key,
        encodedMessage
      );

      return window.btoa(String.fromCharCode(...new Uint8Array(encoded)));
    }

    async function decryptMessage(key, message, iv) {
      const binaryMsg = Uint8Array.from(window.atob(message), (c) =>
        c.charCodeAt(0)
      );

      const encoded = await window.crypto.subtle.decrypt(
        {
          name: "AES-GCM",
          iv: iv,
        },
        key,
        binaryMsg
      );

      const decoder = new TextDecoder();

      return decoder.decode(encoded);
    }

    agreeSharedSecretKey();
  </script>
  <script></script>
</html>
